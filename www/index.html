<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Basis CAPI Transcoder Test (Minimal Mode)</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 2em;
        }

        #output {
            margin-top: 1em;
            padding: 1em;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            white-space: pre-wrap;
        }
    </style>
</head>

<body>
    <h1>Basis CAPI Transcoder Test (Minimal Mode)</h1>
    <p>Testing `basis_compute_transcoded_image_size_in_bytes` function.</p>
    <p>Result will be shown below and in the developer console.</p>
    <div id="output"></div>


    <script type="module">
        import InitTranscoder from '../build/basis_capi_transcoder.js';
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.180.0/+esm'

        async function runTest() {
            const outputDiv = document.getElementById('output');
            outputDiv.textContent = 'Loading module...';

            try {
                outputDiv.textContent = 'Fetching wasm binary...';
                const wasmResponse = await fetch('../build/basis_capi_transcoder.wasm');
                const wasmBinary = await wasmResponse.arrayBuffer();
                outputDiv.textContent = 'Wasm binary fetched.';

                const transcoderModule = await InitTranscoder({
                    wasm: wasmBinary
                });
                outputDiv.textContent = 'Module loaded. Cwrapping function...';
                console.log('Inspecting basisModule object:', transcoderModule);

                const heapU8 = transcoderModule.HEAPU8;

                function getNumberArgTypes(count) {
                    return Array.from({ length: count }, () => 'number');
                }

                const basisu_transcoder_init = transcoderModule.ccall('basisu_transcoder_init', 'void', []);
                const ktx2_transcoder_instance = transcoderModule.ccall('ktx2_transcoder_new', 'number', []);
                const ktx2_transcoder_init = transcoderModule.cwrap('ktx2_transcoder_init', 'boolean', getNumberArgTypes(3));
                const ktx2_transcoder_get_basis_tex_format = transcoderModule.cwrap('ktx2_transcoder_get_basis_tex_format', 'number', getNumberArgTypes(1));
                const ktx2_transcoder_start_transcoding = transcoderModule.cwrap('ktx2_transcoder_start_transcoding', 'boolean', getNumberArgTypes(1));
                const ktx2_transcoder_get_image_level_info = transcoderModule.cwrap('ktx2_transcoder_get_image_level_info', 'boolean', getNumberArgTypes(5));
                const basis_compute_transcoded_image_size_in_bytes = transcoderModule.cwrap('basis_compute_transcoded_image_size_in_bytes', 'number', getNumberArgTypes(3));
                const basis_transcoder_format_is_uncompressed = transcoderModule.cwrap('basis_transcoder_format_is_uncompressed', 'boolean', getNumberArgTypes(1));
                const basis_get_bytes_per_block_or_pixel = transcoderModule.cwrap('basis_get_bytes_per_block_or_pixel', 'number', getNumberArgTypes(1));
                const transcode_image_level = transcoderModule.cwrap('transcode_image_level', 'boolean', getNumberArgTypes(13));

                let inputBufferPtr = 0;
                let inputBufferSize = 0;

                function ktx2_instance_transcoder_init(dataView) {
                    // 在 transcoderModule 中分配内存，把数据复制到内存中
                    if (inputBufferSize < dataView.byteLength) {
                        transcoderModule._free(inputBufferPtr);
                        inputBufferPtr = transcoderModule._malloc(dataView.byteLength);
                        inputBufferSize = dataView.byteLength;
                    }

                    heapU8.set(new Uint8Array(dataView), inputBufferPtr);

                    return ktx2_transcoder_init(ktx2_transcoder_instance, inputBufferPtr, dataView.byteLength);
                }

                function ktx2_instance_transcoder_get_basis_tex_format() {
                    return ktx2_transcoder_get_basis_tex_format(ktx2_transcoder_instance);
                }

                function ktx2_instance_transcoder_start_transcoding() {
                    return ktx2_transcoder_start_transcoding(ktx2_transcoder_instance);
                }
                // // Information about a single 2D texture "image" in a KTX2 file.
                // struct ktx2_image_level_info
                // {
                // 	// The mipmap level index (0=largest), texture array layer index, and cubemap face index of the image.
                // 	uint32_t m_level_index;
                // 	uint32_t m_layer_index;
                // 	uint32_t m_face_index;

                // 	// The image's actual (or the original source image's) width/height in pixels, which may not be divisible by 4 pixels.
                // 	uint32_t m_orig_width;
                // 	uint32_t m_orig_height;

                // 	// The image's physical width/height, which will always be divisible by 4 pixels.
                // 	uint32_t m_width;
                // 	uint32_t m_height;

                // 	// The texture's dimensions in 4x4 or 6x6 texel blocks.
                // 	uint32_t m_num_blocks_x;
                // 	uint32_t m_num_blocks_y;

                // 	// The format's block width/height (currently either 4 or 6).
                // 	uint32_t m_block_width;
                // 	uint32_t m_block_height;

                // 	// The total number of blocks
                // 	uint32_t m_total_blocks;

                // 	// true if the image has alpha data
                // 	bool m_alpha_flag;

                // 	// true if the image is an I-Frame. Currently, for ETC1S textures, the first frame will always be an I-Frame, and subsequent frames will always be P-Frames.
                // 	bool m_iframe_flag;
                // };
                const ImageLevelInfoSize = 12 * 4 + 4;
                const imageLevelInfoInstance = transcoderModule._malloc(ImageLevelInfoSize);
                const imageLevelInfoBuffer = new Uint32Array(heapU8.buffer, heapU8.byteOffset + imageLevelInfoInstance, ImageLevelInfoSize / 4);

                function image_level_info_get_ori_width() {
                    return imageLevelInfoBuffer[3];
                }
                function image_level_info_get_ori_height() {
                    return imageLevelInfoBuffer[4];
                }

                function ktx2_instance_transcoder_get_image_level_info(levelIndex, layer_index, face_index) {
                    return ktx2_transcoder_get_image_level_info(ktx2_transcoder_instance, imageLevelInfoInstance, levelIndex, layer_index, face_index);
                }

                let outputBufferPtr = 0;
                let outputBufferSize = 0;
                let outputView = null;

                function ktx2_instance_transcoder_transcode(levelIndex, layer_index, face_index, transcoder_format) {
                    if (!ktx2_instance_transcoder_get_image_level_info(levelIndex, layer_index, face_index)) {
                        throw new Error('ktx2_instance_transcoder_get_image_level_info failed');
                    }
                    const orig_width = image_level_info_get_ori_width();
                    const orig_height = image_level_info_get_ori_height();
                    const result_image_size_in_bytes = basis_compute_transcoded_image_size_in_bytes(transcoder_format, orig_width, orig_height);
                    if (outputBufferSize < result_image_size_in_bytes) {
                        transcoderModule._free(outputBufferPtr);
                        outputBufferPtr = transcoderModule._malloc(result_image_size_in_bytes);
                        outputBufferSize = result_image_size_in_bytes;
                    }
                    outputView = new Uint8Array(heapU8.buffer, heapU8.byteOffset + outputBufferPtr, result_image_size_in_bytes);
                    if (basis_transcoder_format_is_uncompressed(transcoder_format)) {
                        return transcode_image_level(
                            ktx2_transcoder_instance, levelIndex, layer_index, face_index,
                            outputBufferPtr, orig_width * orig_height, transcoder_format,
                            0, orig_width, orig_height, -1, -1, 0);
                    } else {
                        const bytes_per_block = basis_get_bytes_per_block_or_pixel(transcoder_format);
                        return transcode_image_level(
                            ktx2_transcoder_instance, levelIndex, layer_index, face_index,
                            outputBufferPtr, result_image_size_in_bytes / bytes_per_block, transcoder_format,
                            0, 0, 0, -1, -1, 0);
                    }
                }

                outputDiv.textContent = 'Download test KTX2 file';

                const ktx2url = './kodim23.ktx2';
                const ktx2Response = await fetch(ktx2url);
                const ktx2Buffer = await ktx2Response.arrayBuffer();
                outputDiv.textContent = 'KTX2 file downloaded.';

                const init_result = ktx2_instance_transcoder_init(ktx2Buffer);
                outputDiv.textContent = `KTX2 file initialized: ${init_result}`;
                console.log('KTX2 file initialized:', init_result);

                const basis_tex_format = ktx2_instance_transcoder_get_basis_tex_format();
                outputDiv.textContent = `Basis texture format: ${basis_tex_format}`;
                console.log('Basis texture format:', basis_tex_format);

                const start_transcoding_result = ktx2_instance_transcoder_start_transcoding();
                outputDiv.textContent = `KTX2 file transcoding started: ${start_transcoding_result}`;
                console.log('KTX2 file transcoding started:', start_transcoding_result);

                const get_image_level_info_result = ktx2_instance_transcoder_get_image_level_info(0, 0, 0);
                outputDiv.textContent = `KTX2 file image level info: ${get_image_level_info_result}`;
                console.log('KTX2 file image level info:', get_image_level_info_result, imageLevelInfoBuffer);

                const ori_width = image_level_info_get_ori_width();
                const ori_height = image_level_info_get_ori_height();
                const cTFETC1_RGB = 0;
                const cTFBC3_RGBA = 3;
                const cTFRGBA32 = 13;
                const transcoder_format = cTFBC3_RGBA;
                const isUncompress = basis_transcoder_format_is_uncompressed(transcoder_format);
                const result_image_size_in_bytes = basis_compute_transcoded_image_size_in_bytes(transcoder_format, ori_width, ori_height);
                outputDiv.textContent = `basis_compute_transcoded_image_size_in_bytes(
  format: ${transcoder_format} (isUncompress: ${isUncompress}),
  width: ${ori_width},
  height: ${ori_height}
) = ${result_image_size_in_bytes} bytes`;
                console.log(`basis_compute_transcoded_image_size_in_bytes(
  format: ${transcoder_format} (isUncompress: ${isUncompress}),
  width: ${ori_width},
  height: ${ori_height}
) = ${result_image_size_in_bytes} bytes`);

                const transcode_result = ktx2_instance_transcoder_transcode(0, 0, 0, transcoder_format);
                outputDiv.textContent = `KTX2 file transcoded: ${transcode_result}`;
                console.log('KTX2 file transcoded:', transcode_result);

                // 创建场景、相机和渲染器
                const scene = new THREE.Scene();
                const renderer = new THREE.WebGLRenderer();
                renderer.setSize(ori_width, ori_height);
                document.body.appendChild(renderer.domElement);

                // 使用正交相机精确匹配 canvas 尺寸
                const camera = new THREE.OrthographicCamera(
                    ori_width / -2,   // left
                    ori_width / 2,    // right
                    ori_height / 2,   // top
                    ori_height / -2,  // bottom
                    1,            // near
                    1000          // far
                );
                camera.position.z = 5;

                // 创建 CompressedTexture（单 mipmap 级别）
                const texture = new THREE.CompressedTexture(
                    [{
                        data: outputView,
                        width: ori_width,
                        height: ori_height,
                    }], // mipmaps 数组：这里是单级别
                    ori_width,
                    ori_height,
                    THREE.RGBA_S3TC_DXT3_Format,
                );
                texture.needsUpdate = true; // 标记为需要更新到 GPU
                texture.colorSpace = THREE.SRGBColorSpace;

                // 创建材质和几何体（一个平面来显示纹理）
                const material = new THREE.MeshBasicMaterial({ map: texture });
                const geometry = new THREE.PlaneGeometry(ori_width, ori_height);

                // Manually flip the UVs for the compressed texture, as texture.flipY is not supported.
                const uvs = geometry.attributes.uv;
                for (let i = 0; i < uvs.count; i++) {
                    uvs.setY(i, 1 - uvs.getY(i));
                }

                const plane = new THREE.Mesh(geometry, material);
                plane.position.z = 0;

                // 添加到场景
                scene.add(plane);
                // 渲染一次（静态显示，无需循环）
                renderer.render(scene, camera);
                
            } catch (err) {
                console.error('Test failed:', err);
                outputDiv.textContent = `Test failed: ${err}`;
            }
        }

        runTest();
    </script>
</body>

</html>